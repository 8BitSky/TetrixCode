//Yahboom Line Sensor Test Code
//CCHS2026

#include <PRIZM.h>      // include the PRIZM library

PRIZM prizm;            // instantiate a PRIZM object "prizm" so we can use its functions


#include <Wire.h>

#define SENSOR_ADDR 0x12
#define RAW_REG     0x00

// If lineMask looks backwards (white shows as 1s), flip this.
#define INVERT_RAW true

void setup() {
  prizm.PrizmBegin();   // initialize the PRIZM controller
  Serial.begin(115200);
  delay(200);

  Wire.begin();         // Use PRIZM's Arduino-compatible I2C
  Wire.setClock(100000);
//Comment out following lines in actual code
  Serial.println("\nPRIZM + Yahboom 8ch line sensor (I2C 0x12)");
  Serial.print("INVERT_RAW = ");
  Serial.println(INVERT_RAW ? "true (recommended for black line)" : "false");
  Serial.println("Format: raw=xxxxxxxx mask=xxxxxxxx count=N pos=P");

}

void loop() {     // repeat this code in a loop
  //This code runs the helper functions to print info to serial monitor and allow sensor to be configured
  //In production code, the following can be placed into a LinePosition function to determine if/where line is present
  //This data can then be used to help influence a state machine (enumerations), nested IF/ELSE statements, or Switch statement
  //to control line follow logic
  byte raw = readRawByte();
  byte mask = toLineMask(raw);     // 1 = black line
  int count = bitCount8(mask);     // Important for determining line thickness, junctions turns
  int pos = linePosition(mask);    // Important for determining line placement for steering (Center is 3500, error = 3500- cur_position)

  Serial.print("raw=");
  printBits(raw);

  Serial.print(" mask=");
  printBits(mask);

  Serial.print(" count=");
  Serial.print(count);

  Serial.print(" pos=");
  Serial.println(pos);

  delay(100);

}




//Function reads/talks to I2C sensors and returns infromation in the form of a byte
byte readRawByte() {
  Wire.beginTransmission(SENSOR_ADDR);
  Wire.write(RAW_REG);
  Wire.endTransmission(false);     // repeated start

  Wire.requestFrom(SENSOR_ADDR, 1);
  if (Wire.available()) return Wire.read();

  return 0xFF;
}

//This function inverts the byte into a mask (example: 110011 (zero represent line) gets masked to 001100 (1 represent line)
//Masking to the value of 1 allows for future addition and line conversions into a number which represents ration of the line
//in a left to right direction
byte toLineMask(byte raw) {
  // Goal: 1 = black line detected
  return INVERT_RAW ? (byte)~raw : raw;
}

//Function counts total amount of "1's" in mask to let program know line thickness
int bitCount8(byte x) {
  int c = 0;
  for (int i = 0; i < 8; i++) c += (x >> i) & 1;
  return c;
}


// Function lets program know the weighted position: 0..7000 across sensors (bit0..bit7). 0=left, 3500=middle, 7000=right 
int linePosition(byte lineMask) {
  long sum = 0;
  long wsum = 0;

  for (int i = 0; i < 8; i++) {
    int v = (lineMask >> i) & 1;   // 1 if black
    sum += v;
    wsum += (long)v * (i * 1000);
  }

  if (sum == 0) return -1;         // lost line
  return (int)(wsum / sum);
}

//Helper function to print data to serial monitor
void printBits(byte b) {
  for (int i = 7; i >= 0; i--) {
    Serial.print((b >> i) & 1);
  }
}








